import { PDFReader } from "../libs/models.js";
import axios from "axios";
import {
  Message,
  TextChannel,
  ThreadAutoArchiveDuration,
  ThreadChannel,
} from "discord.js";
import fs from "fs";

/**
 *
 * @param {Message} message
 */
export async function handlePdfSummarizeRoute(message) {
  // check if the link is arxiv link
  // https://arxiv.org/abs/{id}
  const isSummaryCommand = message.content.startsWith("!요약");
  
  const arxivRegex = /https:\/\/arxiv\.org\/abs\/([0-9]{4}\.[0-9]{5})/;
  const isArxivLink = arxivRegex.test(message.content);

  const isPdf = message.attachments.size > 0 && message.attachments.first().name.endsWith(".pdf");

  if (isSummaryCommand && isPdf) {

    // download file if isArxivLink
    await message.channel.sendTyping();
    const attachment = message.attachments.first();

    // check if the attachment is a PDF file
    if (!attachment.name.endsWith(".pdf")) {
      await message.reply("PDF 파일만 요약할 수 있어요!");
      return;
    }

    // check if the attachments folder exists
    await checkAttachmentsFolderExists();

    const messageChannel = message.channel;

    // download the attachment
    const botMessage = await message.reply("파일 다운로드 중...");
    const filePath = await fetchAttachment(messageChannel, attachment.url, attachment.name);

    botMessage.edit("파일 다운로드 완료! 요약 중...");
    const thread = await createNewThread(messageChannel, attachment.name);

    // mention thread
    botMessage.edit(`파일 다운로드 완료! ${thread} 에서 요약 중...`);

    thread.sendTyping();

    // summarize the PDF file
    const stream = streamPDFSummarizer(filePath, attachment.name);

    let response = "";

    for await (const chunk of stream) {
      response += chunk;
      response = splitSendMessages(response, thread);
    }

    if (response.length > 0) {
      await thread.send(response);
    }

    botMessage.edit(`요약 완료! ${thread} 에서 확인해주세요!`);

    deleteFile(filePath);
  }
}

async function checkAttachmentsFolderExists() {
  try {
    await fs.promises.access("./attachments");
  } catch (err) {
    if (err.code === "ENOENT") {
      await fs.promises.mkdir("./attachments");
    } else {
      throw err;
    }
  }
}

/**
 *
 * @param {TextChannel} channel
 * @param {*} url
 * @param {*} name
 * @returns {Promise<string>} file path
 */
export async function fetchAttachment(channel, url, name) {
  console.log("Downloading attachment from", url);
  const { data } = await axios.get(url, { responseType: "stream" });
  data.pipe(
    fs.createWriteStream(`./attachments/${name}`, {
      autoClose: true,
    }).on("error", (err) => {
      console.error(err);
      channel.send("파일 다운로드 중 오류가 발생했어요!");
    })
  );
  const promise = new Promise((resolve, reject) => {
    data.on("end", () => resolve(`./attachments/${name}`));
    data.on("error", (err) => reject(err));
  });
  return promise;
}

/**
 *
 * @param {TextChannel} channel
 * @param {string} title
 * @returns thread
 */
export async function createNewThread(channel, title) {
  const thread = await channel.threads.create({
    name: title,
    autoArchiveDuration: ThreadAutoArchiveDuration.OneDay,
    reason: "Summarize thread generated by samtaegi-pdf",
  });

  return thread;
}

// file을 읽어서 내용을 요약하는 함수
export async function* streamPDFSummarizer(filePath, fileName) {
  console.log("Summarizing PDF file", filePath);

  const reader = new PDFReader();
  await reader.uploadFile(filePath, fileName);

  const stream = reader.generateSummaryStream();
  for await (const chunk of stream) {
    yield chunk;
  }

  reader.deleteFile();
}

/**
 *
 * @param {string} text
 * @param {ThreadChannel} thread
 * @returns remain messages
 */
export function splitSendMessages(text, thread) {
  const MAX_MESSAGE_LENGTH = 2000;

  // 2000자 이상의 메시지가 있다면 2000자가 넘기 전의 마지막 줄바꿈을 찾아서 잘라냄
  if (text.length > MAX_MESSAGE_LENGTH) {
    const splitIndex = text.lastIndexOf("\n", MAX_MESSAGE_LENGTH);
    let message = text.slice(0, splitIndex);
    thread.send(message);
    thread.sendTyping();
    text = text.slice(splitIndex + 1);
  }

  return text;
}

function deleteFile(filePath) {
  try {
    fs.unlinkSync(`${filePath}`);
  } catch (err) {
    console.error(err);
  }
}
