import { PDFReader } from "../libs/models.js";
import axios from "axios";
import {
  Message,
  TextChannel,
  ThreadAutoArchiveDuration,
  ThreadChannel,
} from "discord.js";
import fs from "fs";

/**
 *
 * @param {Message} message
 */
export async function handlePdfSummarizeRoute(message) {
  // check if the link is arxiv link
  // https://arxiv.org/abs/{id}
  const isSummaryCommand = message.content.startsWith("!요약");
  
  const arxivRegex = /https:\/\/arxiv\.org\/abs\/([0-9]{4}\.[0-9]{5})/;
  const isArxivLink = arxivRegex.test(message.content);

  const isPdf = message.attachments.size > 0 && message.attachments.first().name.endsWith(".pdf");

  if (isSummaryCommand && isPdf) {

    // download file if isArxivLink
    await message.channel.sendTyping();
    const attachment = message.attachments.first();

    // check if the attachment is a PDF file
    if (!attachment.name.endsWith(".pdf")) {
      await message.reply("PDF 파일만 요약할 수 있어요!");
      return;
    }

    const [filePath, thread] = await Promise.all([
      // download attachment
      fetchAttachment(attachment.url, attachment.name),

      // create new thread
      createNewThread(message.channel, attachment.name),
    ]);

    // mention thread
    await message.reply(`스레드가 생성되었습니다! ${thread}`);

    thread.sendTyping();

    const stream = streamPDFSummarizer(filePath, attachment.name);

    let response = "";

    for await (const chunk of stream) {
      response += chunk;
      response = splitSendMessages(response, thread);
    }

    if (response.length > 0) {
      await thread.send(response);
    }
  }
}

/**
 *
 * @param {*} url
 * @param {*} name
 * @returns {Promise<string>} file path
 */
export async function fetchAttachment(url, name) {
  console.log("Downloading attachment from", url);
  const { data } = await axios.get(url, { responseType: "stream" });
  data.pipe(
    fs.createWriteStream(`./attachments/${name}`, {
      autoClose: true,
    })
  );
  const promise = new Promise((resolve, reject) => {
    data.on("end", () => resolve(`./attachments/${name}`));
    data.on("error", (err) => reject(err));
  });
  return promise;
}

/**
 *
 * @param {TextChannel} channel
 * @param {string} title
 * @returns thread
 */
export async function createNewThread(channel, title) {
  const thread = await channel.threads.create({
    name: title,
    autoArchiveDuration: ThreadAutoArchiveDuration.OneDay,
    reason: "Summarize thread generated by samtaegi-pdf",
  });

  return thread;
}

// file을 읽어서 내용을 요약하는 함수
export async function* streamPDFSummarizer(filePath, fileName) {
  console.log("Summarizing PDF file", filePath);

  const reader = new PDFReader();
  await reader.uploadFile(filePath, fileName);

  const stream = reader.generateSummaryStream();
  for await (const chunk of stream) {
    yield chunk;
  }
}

/**
 *
 * @param {string} text
 * @param {ThreadChannel} thread
 * @returns remain messages
 */
export function splitSendMessages(text, thread) {
  const MAX_MESSAGE_LENGTH = 2000;

  // 2000자 이상의 메시지가 있다면 2000자가 넘기 전의 마지막 줄바꿈을 찾아서 잘라냄
  if (text.length > MAX_MESSAGE_LENGTH) {
    const splitIndex = text.lastIndexOf("\n", MAX_MESSAGE_LENGTH);
    let message = text.slice(0, splitIndex);
    thread.send(message);
    thread.sendTyping();
    text = text.slice(splitIndex + 1);
  }

  return text;
}
